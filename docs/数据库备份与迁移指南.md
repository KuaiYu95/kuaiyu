# 数据库备份与迁移文档

## 一、数据库备份

### 1.1 手动备份

#### 使用 mysqldump 备份

```bash
# 备份整个数据库
mysqldump -u root -p --single-transaction --routines --triggers \
  --databases blog_db > backup_$(date +%Y%m%d_%H%M%S).sql

# 备份指定表
mysqldump -u root -p blog_db posts comments tags > backup_tables_$(date +%Y%m%d_%H%M%S).sql

# 备份并压缩
mysqldump -u root -p --single-transaction --routines --triggers \
  --databases blog_db | gzip > backup_$(date +%Y%m%d_%H%M%S).sql.gz

# 备份到远程服务器
mysqldump -u root -p blog_db | ssh user@remote_host "cat > /backup/backup_$(date +%Y%m%d_%H%M%S).sql"
```

#### 备份参数说明

- `--single-transaction`: 保证数据一致性，适用于 InnoDB
- `--routines`: 备份存储过程和函数
- `--triggers`: 备份触发器
- `--databases`: 备份整个数据库（包括创建数据库语句）
- `--no-data`: 只备份表结构，不备份数据
- `--no-create-info`: 只备份数据，不备份表结构

### 1.2 自动备份脚本

#### 创建备份脚本

```bash
#!/bin/bash
# backup.sh

# 配置
DB_USER="root"
DB_PASS="your_password"
DB_NAME="blog_db"
BACKUP_DIR="/backup/mysql"
RETENTION_DAYS=7  # 保留7天

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份文件名
BACKUP_FILE="backup_${DB_NAME}_$(date +%Y%m%d_%H%M%S).sql.gz"

# 执行备份
mysqldump -u $DB_USER -p$DB_PASS \
  --single-transaction \
  --routines \
  --triggers \
  --databases $DB_NAME | gzip > $BACKUP_DIR/$BACKUP_FILE

# 检查备份是否成功
if [ $? -eq 0 ]; then
  echo "备份成功: $BACKUP_FILE"

  # 删除旧备份
  find $BACKUP_DIR -name "backup_${DB_NAME}_*.sql.gz" -mtime +$RETENTION_DAYS -delete

  # 可选：上传到云存储
  # aws s3 cp $BACKUP_DIR/$BACKUP_FILE s3://your-bucket/backups/
else
  echo "备份失败!"
  exit 1
fi
```

#### 设置定时任务（Cron）

```bash
# 编辑 crontab
crontab -e

# 每天凌晨2点执行备份
0 2 * * * /path/to/backup.sh >> /var/log/backup.log 2>&1

# 每小时备份一次（可选）
0 * * * * /path/to/backup.sh >> /var/log/backup.log 2>&1
```

### 1.3 Docker 环境备份

#### 备份脚本（Docker）

```bash
#!/bin/bash
# backup-docker.sh

CONTAINER_NAME="blog_mysql"
DB_NAME="blog_db"
DB_USER="root"
DB_PASS="your_password"
BACKUP_DIR="./backups"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

# 执行备份
docker exec $CONTAINER_NAME mysqldump -u $DB_USER -p$DB_PASS \
  --single-transaction \
  --routines \
  --triggers \
  --databases $DB_NAME | gzip > $BACKUP_DIR/backup_${DATE}.sql.gz

# 复制备份文件到容器外
docker cp $CONTAINER_NAME:/tmp/backup.sql.gz $BACKUP_DIR/backup_${DATE}.sql.gz

echo "备份完成: $BACKUP_DIR/backup_${DATE}.sql.gz"
```

### 1.4 备份验证

#### 验证备份文件完整性

```bash
# 检查备份文件是否损坏
gunzip -t backup_20240101_120000.sql.gz

# 查看备份文件内容（前几行）
zcat backup_20240101_120000.sql.gz | head -20

# 测试恢复（在测试数据库）
mysql -u root -p test_db < backup_20240101_120000.sql
```

## 二、数据库恢复

### 2.1 从 SQL 文件恢复

#### 恢复整个数据库

```bash
# 恢复未压缩的备份
mysql -u root -p < backup_20240101_120000.sql

# 恢复压缩的备份
gunzip < backup_20240101_120000.sql.gz | mysql -u root -p

# 恢复指定数据库
mysql -u root -p blog_db < backup_20240101_120000.sql
```

#### 恢复指定表

```bash
# 从完整备份中提取表数据
sed -n '/^-- Table structure for table `posts`/,/^-- Table structure for table/p' \
  backup_20240101_120000.sql > posts_backup.sql

# 恢复表
mysql -u root -p blog_db < posts_backup.sql
```

### 2.2 Docker 环境恢复

```bash
# 方法1: 从文件恢复
gunzip < backup_20240101_120000.sql.gz | \
  docker exec -i blog_mysql mysql -u root -p$DB_PASS blog_db

# 方法2: 复制文件到容器后恢复
docker cp backup_20240101_120000.sql.gz blog_mysql:/tmp/
docker exec blog_mysql sh -c 'gunzip < /tmp/backup_20240101_120000.sql.gz | mysql -u root -p$DB_PASS blog_db'
```

### 2.3 恢复前准备

#### 1. 停止相关服务

```bash
# 停止应用服务
docker-compose stop api frontend admin

# 或停止单个服务
docker stop blog_api
```

#### 2. 备份当前数据（以防万一）

```bash
# 恢复前先备份当前数据
mysqldump -u root -p blog_db > before_restore_$(date +%Y%m%d_%H%M%S).sql
```

#### 3. 清空现有数据（可选）

```bash
# 删除数据库（谨慎操作）
mysql -u root -p -e "DROP DATABASE IF EXISTS blog_db;"
mysql -u root -p -e "CREATE DATABASE blog_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
```

## 三、数据库迁移

### 3.1 迁移到新服务器

#### 步骤 1: 在源服务器备份

```bash
# 完整备份
mysqldump -u root -p --single-transaction --routines --triggers \
  --databases blog_db | gzip > migration_backup_$(date +%Y%m%d).sql.gz

# 验证备份
gunzip -t migration_backup_$(date +%Y%m%d).sql.gz
```

#### 步骤 2: 传输备份文件

```bash
# 使用 SCP
scp migration_backup_20240101.sql.gz user@new_server:/backup/

# 使用 RSYNC
rsync -avz migration_backup_20240101.sql.gz user@new_server:/backup/

# 使用云存储（推荐）
aws s3 cp migration_backup_20240101.sql.gz s3://your-bucket/migrations/
```

#### 步骤 3: 在新服务器恢复

```bash
# 在新服务器上创建数据库
mysql -u root -p -e "CREATE DATABASE blog_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

# 恢复数据
gunzip < migration_backup_20240101.sql.gz | mysql -u root -p blog_db

# 验证数据
mysql -u root -p -e "USE blog_db; SHOW TABLES; SELECT COUNT(*) FROM posts;"
```

### 3.2 迁移到 Docker 环境

#### 从传统 MySQL 迁移到 Docker

```bash
# 1. 在源服务器备份
mysqldump -u root -p --single-transaction --routines --triggers \
  --databases blog_db > migration.sql

# 2. 启动 Docker MySQL 容器
docker-compose up -d mysql

# 3. 等待 MySQL 启动
sleep 10

# 4. 恢复数据
docker exec -i blog_mysql mysql -u root -p$MYSQL_ROOT_PASSWORD < migration.sql

# 5. 验证
docker exec blog_mysql mysql -u root -p$MYSQL_ROOT_PASSWORD -e "USE blog_db; SHOW TABLES;"
```

### 3.3 版本升级迁移

#### MySQL 5.7 升级到 8.0

```bash
# 1. 备份数据
mysqldump -u root -p --all-databases > full_backup.sql

# 2. 检查兼容性
mysql_upgrade --check

# 3. 升级 MySQL（根据实际情况选择方法）
# 方法A: 使用 mysqldump 导出导入
mysqldump -u root -p blog_db > blog_db.sql
# 在新版本 MySQL 中导入
mysql -u root -p blog_db < blog_db.sql

# 方法B: 使用 mysql_upgrade（需要停止服务）
systemctl stop mysql
# 升级 MySQL 版本
systemctl start mysql
mysql_upgrade -u root -p
```

### 3.4 数据迁移脚本

#### 自动化迁移脚本

```bash
#!/bin/bash
# migrate.sh

SOURCE_HOST="old_server"
SOURCE_DB="blog_db"
SOURCE_USER="root"
SOURCE_PASS="old_password"

TARGET_HOST="new_server"
TARGET_DB="blog_db"
TARGET_USER="root"
TARGET_PASS="new_password"

BACKUP_FILE="migration_$(date +%Y%m%d_%H%M%S).sql"

echo "开始迁移..."

# 1. 备份源数据库
echo "备份源数据库..."
mysqldump -h $SOURCE_HOST -u $SOURCE_USER -p$SOURCE_PASS \
  --single-transaction --routines --triggers \
  --databases $SOURCE_DB > $BACKUP_FILE

# 2. 验证备份
if [ ! -f $BACKUP_FILE ]; then
  echo "备份失败!"
  exit 1
fi

# 3. 传输到目标服务器
echo "传输备份文件..."
scp $BACKUP_FILE user@$TARGET_HOST:/tmp/

# 4. 在目标服务器恢复
echo "恢复数据..."
ssh user@$TARGET_HOST "mysql -u $TARGET_USER -p$TARGET_PASS < /tmp/$BACKUP_FILE"

# 5. 验证迁移
echo "验证迁移..."
RECORD_COUNT=$(ssh user@$TARGET_HOST "mysql -u $TARGET_USER -p$TARGET_PASS -e 'SELECT COUNT(*) FROM $TARGET_DB.posts;'")
echo "迁移完成，记录数: $RECORD_COUNT"

# 6. 清理
rm $BACKUP_FILE
```

## 四、数据同步

### 4.1 主从复制（Master-Slave）

#### 配置主服务器（Master）

```sql
-- 1. 修改 my.cnf
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog-format = ROW

-- 2. 创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 3. 查看二进制日志位置
SHOW MASTER STATUS;
```

#### 配置从服务器（Slave）

```sql
-- 1. 修改 my.cnf
[mysqld]
server-id = 2
relay-log = mysql-relay-bin

-- 2. 配置主服务器信息
CHANGE MASTER TO
  MASTER_HOST='master_ip',
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

-- 3. 启动复制
START SLAVE;

-- 4. 查看复制状态
SHOW SLAVE STATUS\G
```

### 4.2 增量备份与恢复

#### 基于二进制日志的增量备份

```bash
# 1. 启用二进制日志
# 在 my.cnf 中添加:
# log-bin = mysql-bin

# 2. 全量备份
mysqldump -u root -p --single-transaction --master-data=2 \
  --databases blog_db > full_backup.sql

# 3. 增量备份（备份二进制日志）
mysqlbinlog --start-datetime="2024-01-01 00:00:00" \
  --stop-datetime="2024-01-02 00:00:00" \
  mysql-bin.000001 > incremental_backup.sql

# 4. 恢复全量备份
mysql -u root -p blog_db < full_backup.sql

# 5. 恢复增量备份
mysql -u root -p blog_db < incremental_backup.sql
```

## 五、备份策略建议

### 5.1 备份频率

- **生产环境**: 每天全量备份 + 每小时增量备份
- **开发环境**: 每天全量备份
- **测试环境**: 每周全量备份

### 5.2 备份保留策略

- **本地备份**: 保留最近 7 天
- **远程备份**: 保留最近 30 天
- **月度备份**: 保留最近 12 个月
- **年度备份**: 永久保留

### 5.3 备份验证

- 每周验证一次备份文件完整性
- 每月进行一次恢复测试
- 记录备份和恢复日志

### 5.4 备份存储

- **本地存储**: 服务器本地磁盘
- **远程存储**: 云存储（OSS、S3 等）
- **异地备份**: 不同地区的服务器

## 六、常见问题

### 6.1 备份文件过大

```bash
# 使用压缩
mysqldump ... | gzip > backup.sql.gz

# 只备份数据，不备份结构（如果结构不变）
mysqldump --no-create-info ...

# 分批备份大表
mysqldump --where="id < 10000" blog_db posts > posts_part1.sql
```

### 6.2 备份时锁表

```bash
# 使用 --single-transaction（InnoDB）
mysqldump --single-transaction ...

# 使用 --lock-tables=false（MyISAM，不推荐）
mysqldump --lock-tables=false ...
```

### 6.3 恢复时字符集问题

```bash
# 指定字符集恢复
mysql -u root -p --default-character-set=utf8mb4 blog_db < backup.sql

# 或在 SQL 文件开头添加
SET NAMES utf8mb4;
```

### 6.4 恢复时外键约束问题

```bash
# 临时禁用外键检查
mysql -u root -p -e "SET FOREIGN_KEY_CHECKS=0; SOURCE backup.sql; SET FOREIGN_KEY_CHECKS=1;"
```

## 七、监控与告警

### 7.1 备份监控脚本

```bash
#!/bin/bash
# check_backup.sh

BACKUP_DIR="/backup/mysql"
ALERT_EMAIL="admin@example.com"

# 检查最新备份
LATEST_BACKUP=$(ls -t $BACKUP_DIR/*.sql.gz 2>/dev/null | head -1)

if [ -z "$LATEST_BACKUP" ]; then
  echo "警告: 没有找到备份文件!" | mail -s "备份检查失败" $ALERT_EMAIL
  exit 1
fi

# 检查备份时间（超过24小时）
BACKUP_AGE=$(($(date +%s) - $(stat -c %Y $LATEST_BACKUP)))
MAX_AGE=86400  # 24小时

if [ $BACKUP_AGE -gt $MAX_AGE ]; then
  echo "警告: 最新备份超过24小时!" | mail -s "备份检查失败" $ALERT_EMAIL
  exit 1
fi

# 检查备份文件大小（小于1MB可能有问题）
BACKUP_SIZE=$(stat -c %s $LATEST_BACKUP)
MIN_SIZE=1048576  # 1MB

if [ $BACKUP_SIZE -lt $MIN_SIZE ]; then
  echo "警告: 备份文件可能不完整!" | mail -s "备份检查失败" $ALERT_EMAIL
  exit 1
fi

echo "备份检查通过: $LATEST_BACKUP"
```

### 7.2 设置监控定时任务

```bash
# 每小时检查一次备份
0 * * * * /path/to/check_backup.sh
```

## 八、最佳实践

1. **定期测试恢复**: 确保备份文件可以正常恢复
2. **多重备份**: 本地 + 远程 + 异地
3. **自动化备份**: 使用脚本和定时任务
4. **监控告警**: 备份失败及时通知
5. **文档记录**: 记录备份和恢复操作
6. **权限控制**: 备份文件加密存储
7. **版本管理**: 保留多个版本的备份
